# -*- coding: utf-8 -*-
"""cab_scraper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aTJk9ZeAqMjwSQBrX0sSeDU5QWMlL4Xr

This program retrieves information about all courses in all departments, including course code, course name, the set of prerequisites, the semester offered, and the professor's name.
It then inserts or updates them in the courses database (coursesDB.db).

All the course information except for prerequisites are retrieved using the Courses@Brown API. The prerequisites are separately scraped from Self Service. Some of the prerequisites had to be edited or entered in the database by hand, as they appeared in inconsistent formats in Self Service. Thus, we manually verified the correctness of prerequisites for a finite number of departments (adding them to a google doc) and are gradually verifying more. We will try to only use verified concentrations for demo day, as others will work but might generate pathways that don't make sense within Brown.

Install the necessary libraries:
"""

!pip install bs4
!pip install requests
!pip install -U -q PyDrive

import json
import requests
import sys
import re
import sqlite3
from google.colab import drive
from bs4 import BeautifulSoup as bs

#Mount Google Drive to access coursesDB
drive.mount('/content/drive/',force_remount=True)
path = '/content/drive/Shared drives/CS32-Final/Data/coursesDB.db'

#url for getting info from self service
ss_url = "https://selfservice.brown.edu/ss/bwckctlg.p_disp_course_detail?cat_term_in=201920&"
#url for the CAB API endpoint
cab_url = "https://cab.brown.edu/api/?page=fose&route=search&"
#headers to log into CAB API
headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.92 Safari/537.36', 'Set-Cookie':'TS01beaa4b=014b44e76b6340eedebf9950637d45867f97b6bd39a4c619f95ae102c1b5addc7c0045d42f42a3df80c83f3ccaae4fde380f653ec2442daef99138815d42e50d0a64ef5369b06b33ba39e4761efc070c6746de3eb5'}

#setting up sqlite db connection
conn = sqlite3.connect(path)
c = conn.cursor()
## When using SQLite, include the following line to ensure foreign key commands are recognized
c.execute('PRAGMA foreign_keys = ON')

class Course:
    def __init__(self, course_id, name, prof, semester, prereqs):
        self.course_id = course_id
        self.name = name
        self.prof = prof
        self.semester = semester
        self.prereqs = prereqs
    def __repr__(self):
        return "Course(" + self.course_id + ", " + self.name + ", " + self.prof + ", " + self.semester + ", " + self.prereqs + ")"
    def __eq__(self, other):
        if (type(self) != type(other)):
          return False
        else:
          return self.course_id == other.course_id
    def __hash__(self):
      return hash(self.course_id)
  
major_request = {
    "other": {"srcdb": "999998"},
    "criteria": [
        {"field": "keyword", "value": "CSCI"}
    ]
}

#Load all class info to get dept codes (e.g. CSCI, MATH)
f = open("/content/drive/Shared drives/CS32-Final/Data/courses.json")
all_classes = json.load(f)
all_major_codes = set()
for course in all_classes["courses"]:
  all_major_codes.add(course["department_code"])
all_major_codes = sorted(all_major_codes)

def insert_into_table(course):
  c.execute('SELECT * FROM courses WHERE course_id="' + str(course.course_id) + '";')
  if (not c.fetchall()):
    # Course not already present in table, so insert new row
    dept = course.course_id.split(" ")[0]
    num = course.course_id.split(" ")[1]
    above_1000 = str(int(int(num[:4]) >= 1000))
    c.execute('INSERT INTO courses VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?);', 
              (course.course_id, course.name, course.prereqs, course.semester, 
               course.prof, "n/a", "n/a", "n/a", "n/a", "n/a", dept, num, above_1000))
  else:
    #set course_name
    c.execute('UPDATE courses SET course_name="'+str(course.name)+'" WHERE course_id="'+str(course.course_id)+'";')
    #set prereqs
    c.execute('UPDATE courses SET prereqs="'+str(course.prereqs)+'" WHERE course_id="'+str(course.course_id)+'";')
    #set professor
    c.execute('UPDATE courses SET professor="'+str(course.prof)+'" WHERE course_id="'+str(course.course_id)+'";')
    #set semester_offered
    c.execute('UPDATE courses SET semester_offered="'+str(course.semester)+'" WHERE course_id="'+str(course.course_id)+'";')
  conn.commit()
  
def insert_all_into_table(courses):
  for major in courses:
    for course in major:
      insert_into_table(course)

# Returns a list of Course, where each contains info for every course in major
# Gets the id, name, and professor, but not semesters or prereqs
def cab_get_courses_in_major(major_code):
  major_request["criteria"][0]["value"] = major_code
  r = requests.post(url = cab_url, data = json.dumps(major_request), 
                            headers = headers)
  classes_info = json.loads(r.text)["results"]
  # Only take section 1
  classes_info = list(filter(lambda c: c["no"] == "S01", classes_info))
  # Set of class id's for classes offered in fall and spring
  courses_both_sems = set()
  for i in range(0, len(classes_info) - 1):
    if (classes_info[i]["code"] == classes_info[i+1]["code"]):
      #Class has the same code as the class next to it, so it's the same
      #Class offered in both the fall and spring
      courses_both_sems.add(classes_info[i]["code"])
      i += 1 # Skip past duplicate

  courses = []
  for class_info in classes_info:
    courses.append(make_class(class_info, courses_both_sems))
  #courses = list(filter(lambda c: sum(d.course_id == c.course_id for d in courses) == 1, courses))
  print(courses)
  return courses

def make_class(class_info, both_sem_courses):
  class_id = class_info["code"]
  name = re.sub('[\"]', '', class_info["title"])
  prof = class_info["instr"] # remove double quotes
  sem = ""
  if (class_id in both_sem_courses):
    sem = "2"
  else:
    #srcdb='202010' (fall) or '202020' (spring) -> subtract 2, negate, and make string (fall = 0, spring =1, both=2)
    sem = str(-(int(class_info["srcdb"][-2]) - 2)) 
  return Course(class_id, name, prof, sem, "")

def cab_get_courses_all_majors():
  all_courses = []
  for major in all_major_codes:
    all_courses.append(cab_get_courses_in_major(major))
  return all_courses

"""Get all the courses and their information from CAB (except prereqs):"""

all_courses = cab_get_courses_all_majors()

"""Now, we have to get the prerequisites from Self Service and add them to the existing course objects."""

print(all_courses[0:10])

def ss_get_prereqs(course):
  name = course.course_id.split(" ")
  ss_link = ss_url + "subj_code_in=" + name[0] + "&crse_numb_in=" + name[1]
  r = requests.get(ss_link)
  soup = bs(r.text, "html.parser")
  p_header = soup.find_all(class_="fieldlabeltext", string="Prerequisites: ")
  text = soup.find_all(class_="ntdefault")[0].get_text()
  prereqs = [] # prereqs is a list of lists (an AND of OR's), where each sublist represents equivalent classes
  if (p_header):
      # If there is a prerequisites section
      # print them like ((CSCI 0150, CSCI 0170), (CSCI 0160, CSCI 0180))
      # Get all text after "Prerequisites" until bottom of page
      pre_index = text.rfind("Prerequisites:")
      last_part = text[pre_index:]
      last_line = last_part.split("\n")[2].strip()
      # Now split up and figure out the AND's and OR's
      and_split = last_line.split("and")
      for clause in and_split:
          ors = []
          or_split = clause.split("or")
          # Now get the class codes from each or clause
          for c in or_split:
              regex = re.findall("[A-Z][A-Z][A-Z]?[A-Z]? \d\d\d\d[A-Z]?", c)
              if (regex): # Find the course code
                      ors.append(regex[0])
          prereqs.append(ors)
      prereqs = [x for x in prereqs if x] # get the non-empty OR clauses

  #Now make the prereqs string, with '^' = OR and ',' = AND
  pstr = ""
  for i in range(0, len(prereqs)):
      for j in range(0, len(prereqs[i])):
              if (j == len(prereqs[i]) - 1):
                      pstr += prereqs[i][j]
              else:
                      pstr += prereqs[i][j] + "^"
      if (i != len(prereqs) - 1):
              pstr += ","

  # If there was no prerequisites section, double check there aren't prereqs
  # listed in text in the course description
  if (pstr == ""):
      pind = text.find("rereq")
      eind = text.find("Expected")
      lind = text.find("Levels") # An element always after the text description
      start = -1
      if (pind < lind and pind != -1):
          start = pind
      elif (eind < lind and eind != -1):
          start = eind
      if (start != -1):
          period = text.index(".", start) # Look for end of sentence
          reqs = text[start:period] # take from start til end of sentence
          and_split = reqs.split("and") # split on AND
          for clause in and_split:
              ors = []
              or_split = clause.split(",") # split on commas
              # Now get the class codes from each or clause
              for c in or_split:
                  regex = re.findall("[A-Z]?[A-Z]?[A-Z]?[A-Z]? \d\d\d\d[A-Z]?", c)
                  if (regex): # Find the course code
                      ors.append(regex[0].strip())
              prereqs.append(ors)
          prereqs = [x for x in prereqs if x] # get the non-empty OR clauses
          for i in range(0, len(prereqs)):
              for j in range(0, len(prereqs[i])):
                # If a prereq namem doesn't have dept code, add dept code of first listed course code in sentence
                  if (len(prereqs[i][j]) <= 4):
                      prereqs[i][j] = prereqs[0][0].split(" ")[0] + " " + prereqs[i][j]
      # Otherwise, we assume the course has no prereqs
          
      # Make the prereqs string again
      pstr = ""
      for i in range(0, len(prereqs)):
          for j in range(0, len(prereqs[i])):
                  if (j == len(prereqs[i]) - 1):
                          pstr += prereqs[i][j]
                  else:
                          pstr += prereqs[i][j] + "^"
          if (i != len(prereqs) - 1):
                  pstr += ","
                  
  course.prereqs = pstr # Finally, set the prereqs string of the course object

def fill_prereqs():
  for major in all_courses:
    for course in major:
      ss_get_prereqs(course)
      print(course)

"""Add the prerequisites to each course in all_courses:"""

fill_prereqs()

print(all_courses[0:2])

"""Insert or update all courses into the courses database:"""

insert_all_into_table(all_courses)

conn.close()

"""Check the contents of the database:"""

command1 = '''
SELECT
  *
FROM
  courses;
'''

# Do not modify below this line
c.execute(command1)
count = 0
for row in c:
  count += 1
  print(row)
print(count)

# Check for incorrectly formed strings
c.execute('SELECT prereqs FROM courses;')
ps = c.fetchall()
for p in ps:
  if (p[0] and p[0][0].isdigit()):
    print(p[0])
    
c.execute('SELECT course_id FROM courses;')
course_codes = c.fetchall()
print(course_codes)
for course in course_codes:
  split = course[0].split(' ')
  link = ss_url + "subj_code_in=" + split[0] + '&crse_numb_in=' + split[1]
  c.execute('UPDATE courses SET CAB_link="' + str(link) + '" WHERE course_id="' + course[0] + '";')
conn.commit()

c.execute('SELECT course_id, CAB_link FROM courses')
pairs = c.fetchall()
for p in pairs:
  dept = p[0].split(' ')[0]
  num = p[0].split(' ')[1]
  dept_link = re.search('subj_code_in=[A-Z][A-Z][A-Z]?[A-Z]?', p[1])
  num_link = re.search('crse_numb_in=\d\d\d\d[A-Z]?', p[1])
  dl = re.search('[A-Z][A-Z][A-Z]?[A-Z]?', dept_link.group())
  nl = re.search('\d\d\d\d[A-Z]?', num_link.group())
  assert dept == dl.group() and num == nl.group()