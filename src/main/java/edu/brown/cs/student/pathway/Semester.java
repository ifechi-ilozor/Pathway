package edu.brown.cs.student.pathway;

import java.util.List;
import java.util.Set;
import java.util.Iterator;

/**
 * The Semester Class contains the courses a student takes in a specific
 * semester (made in the makePathway method). Additional courses info
 * is in the Semester class that allows Pathway customization in the GUI.
 */

/**
 * Notes on swapping:
 * <p>
 * If I got a Pathway and wanted to edit it, how would I change it?
 * - Swap with course of same category
 * - What if they swap a course that is a next or has a next?
 * - What if they swap a course that is a prereq for another course in pathway?
 * - What if the swap can't happen that semester?
 * - Can we honor workload preference if they swap?
 * <p>
 * - Move course to a different semester (take AI in semester 5 instead of 3)
 * - What if they try to move the course to a semester when it's not offered?
 * - What if they try to move the course to a semester when it's not a source?
 * <p>
 * - Add a desired course
 * - What if they want to add a course to a semester when it's not offered?
 * <p>
 * - Users CANNOT just remove a course (won't satisfy reqs)
 */
public class Semester {
  private List<Node> courses;
  private int semnumber;
  private String courseid1;
  private String courseid2;
  private String courseid3;
  private String courseid4;
  private String coursename1;
  private String coursename2;
  private String coursename3;
  private String coursename4;
  private String prof1;
  private String prof2;
  private String prof3;
  private String prof4;
  private int sems1;
  private int sems2;
  private int sems3;
  private int sems4;
  private double maxhrs;
  private double avghrs;
  private int numcourses;
  private double rating;
  // coursesByCat is the sources this semNumber partitioned by category.
  // This will be used for editing Pathways in the GUI:
  // - can add any course available that sem [info in node]
  // - can move course to any sem it's offered as long as it's a source
  //   [info in semester]
  // - can swap courses of equivalent categories [info in semester]
  private List<Node>[] coursesByCat;
  private int numCategories;

  /**
   * Instantiates a new Semester.
   *
   * @param sem    semester number (1, 2, ...)
   * @param taking courses that the student will take based on the results of the pathway
   */
  public Semester(int sem, List<Node> taking) {
    semnumber = sem;
    courses = taking; // courses generated by algo, before edits
    this.setCourses();
    numcourses = 0;
    maxhrs = 0.0;
    avghrs = 0.0;
    rating = 0.0;
  }

  /**
   * Public getter method to return the maximum hours of a semester.
   *
   * @return a double representing maxhrs variable.
   */
  public double getMaxhrs() {
    return maxhrs;
  }

  /**
   * Sets the statistics for a semester like maxHrs, avghrs, and rating.
   */
  public void setStats() {
    for (Node c : this.courses) {
      maxhrs += c.getMaxHrs();
      avghrs += c.getAvgHrs();
      rating += c.getRating();
    }
  }

  /**
   * Getter method for the rating of a semester.
   *
   * @return a double variable, rating.
   */
  public double getRating() {
    return rating;
  }

  /**
   * Getter to return a double representing the average hours in a semester.
   *
   * @return double, avghrs variable.
   */
  public double getAvghrs() {
    return avghrs;
  }

  public int getNumcourses() {
    numcourses = this.courses.size();
    return numcourses;
  }

  public void setCourses() {
    for (int i = 0; i < courses.size(); i++) {
      switch (i) {
        case 0:
          Node n = courses.get(0);
          courseid1 = n.getId();
          coursename1 = n.getName();
          prof1 = n.getProfessor();
          Set<Integer> semSet = n.getSemestersOffered();
          if (semSet.size() == 2) {
            sems1 = 2;
          } else { // only 1 number in the set
            Iterator<Integer> s = semSet.iterator();
            while (s.hasNext()) {
              sems1 = s.next();
            }
          }
          break;
        case 1:
          n = courses.get(1);
          courseid2 = n.getId();
          coursename2 = n.getName();
          prof2 = n.getProfessor();
          semSet = n.getSemestersOffered();
          if (semSet.size() == 2) {
            sems2 = 2;
          } else { // only 1 number in the set
            Iterator<Integer> s = semSet.iterator();
            while (s.hasNext()) {
              sems2 = s.next();
            }
          }
          break;
        case 2:
          n = courses.get(2);
          courseid3 = n.getId();
          coursename3 = n.getName();
          prof3 = n.getProfessor();
          semSet = n.getSemestersOffered();
          if (semSet.size() == 2) {
            sems3 = 2;
          } else { // only 1 number in the set
            Iterator<Integer> s = semSet.iterator();
            while (s.hasNext()) {
              sems3= s.next();
            }
          }
          break;
        case 3:
          n = courses.get(3);
          courseid4 = n.getId();
          coursename4 = n.getName();
          prof4 = n.getProfessor();
          semSet = n.getSemestersOffered();
          if (semSet.size() == 2) {
            sems4 = 2;
          } else { // only 1 number in the set
            Iterator<Integer> s = semSet.iterator();
            while (s.hasNext()) {
              sems4 = s.next();
            }
          }
          break;
        default:
          break;
      }
    }
  }

  public String getCourseid1() {
    return courseid1;
  }

  public String getCourseid2() {
    return courseid2;
  }

  public String getCourseid3() {
    return courseid3;
  }

  public String getCourseid4() {
    return courseid4;
  }

  public String getCoursename1() {
    return coursename1;
  }

  public String getCoursename2() {
    return coursename2;
  }

  public String getCoursename3() {
    return coursename3;
  }

  public String getCoursename4() {
    return coursename4;
  }

  public String getProf1() {
    return prof1;
  }

  public String getProf2() {
    return prof2;
  }

  public String getProf3() {
    return prof3;
  }

  public String getProf4() {
    return prof4;
  }

  public int getSems1() {
    return sems1;
  }

  public int getSems2() {
    return sems2;
  }

  public int getSems3() {
    return sems3;
  }

  public int getSems4() {
    return sems4;
  }

  /**
   * getSemester gets the semester's integer representation.
   *
   * @return the semester as an integer
   */
  public int getSemnumber() {
    return semnumber;
  }

  /**
   * getCourses gets the courses that will be taken for this semester.
   *
   * @return the courses that will taken in this semester
   */
  public List<Node> getCourses() {
    return courses;
  }

//  /**
//   * addCourse adds a course to this semester.
//   *
//   * @param course the course to add
//   */
//  public void addCourse(Node course) {
//    courses.add(course);
//  }
//
//  /**
//   * removeCourse removes a course if the user wants to switch it out for another course.
//   *
//   * @param course the course
//   */
//  public void removeCourse(Node course) {
//    courses.remove(course);
//  }
//
//  /**
//   * getCourseEquivalents gets the course equivalents for the given course i.e. courses that are
//   * offered in that same semester and satisfy the same requirements within the concentration.
//   *
//   * @param course the course
//   * @return the course equivalents
//   */
//  public List<Node> getCourseEquivalents(Node course) {
//    return coursesByCat[course.getCategory()];
//  }
//
//  /**
//   * getAllCoursesAvailableThisSemester gets all courses available this semester as a list where
//   * the category is the index and the values are the courses that can be taken in this semester
//   * that satisfy the category.
//   *
//   * @return the list of all courses by category that can be taken in this semester
//   */
//  public List<Node>[] getAllCoursesAvailableThisSemester() {
//    return coursesByCat;
//  }

}
